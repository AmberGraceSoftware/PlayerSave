[{"title":"PlayerSave","type":0,"sectionRef":"#","url":"/api/PlayerSave","content":"On this page PlayerSave warning PlayerSave is still a work in progress and does not currently have a full release! Please avoid using PlayerSave in production-bound projects, as the library is not fully tested, and the API may be subject to change PlayerSave is a holistic library that handles storing, replicating, and observing player data in a simple and fault-tolerant way. PlayerSave provides a number of key Mechanisms that can be configured to the needs of a project. PlayerSave is designed to function as expected without much configuration out-of-the-gate, but you should also read the documentation to customize your configuration depending on the features your game includes (for example, trading). For more information, see the Usage Guide","keywords":""},{"title":"PlayerSave","type":0,"sectionRef":"#","url":"/docs/intro","content":"PlayerSave danger PlayerSave is still a work in progress and does not currently have a full release! Please avoiding PlayerSave in production-bound projects, as the library is not fully tested, and the API may be subject to change","keywords":""},{"title":"Save","type":0,"sectionRef":"#","url":"/api/Save","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Save","url":"/api/Save#functions","content":" "},{"title":"Get​","type":1,"pageTitle":"Save","url":"/api/Save#Get","content":"&lt;/&gt; Save:Get( keyPath: KeyPath, defaultValue:: any? ) → any   "},{"title":"Set​","type":1,"pageTitle":"Save","url":"/api/Save#Set","content":"&lt;/&gt; Save:Set( keyPath: KeyPath, newValue: any ) → ()   "},{"title":"Subscribe​","type":1,"pageTitle":"Save","url":"/api/Save#Subscribe","content":"&lt;/&gt; Save:Subscribe( keyPath: KeyPath, listener: (value: any) → (), immediatelyCallListener: boolean? ) → () → ()  "},{"title":"Mechanisms","type":0,"sectionRef":"#","url":"/docs/mechanisms","content":"","keywords":""},{"title":"PlayerSave Mechanisms Overview:​","type":1,"pageTitle":"Mechanisms","url":"/docs/mechanisms#playersave-mechanisms-overview","content":"Exit SavesAuto SavesData ReplicationSave RetriesPlace Teleport ToleranceBindToCloseTrade TransactionsData MigrationLoggingDebugger info This documentation page is currently in progress "},{"title":"Incorrect API Usage","type":0,"sectionRef":"#","url":"/docs/incorrect_api_usage","content":"","keywords":""},{"title":"Table Mutations​","type":1,"pageTitle":"Incorrect API Usage","url":"/docs/incorrect_api_usage#table-mutations","content":"One core feature of PlayerSave is that all changes to player save data are Observable. This is achieved by only allowing data to be changed in a player's save via Setter methods. However, there are still ways to accidentally modify save data that the PlayerSave library is not able to observe to at runtime! danger You should never directly edit a table returned by save:Get()! For example: local inventory = save:Get(&quot;Inventory&quot;, {}) table.insert(inventory, &quot;Sword&quot;) -- Incorrect! `inventory` should not be mutated save:Set(&quot;Inventory&quot;, inventory) -- Will throw an error. Mutating a value directly like this will result in desynchronization between server data and client data. It may also prevent listeners connected via save:Subscribe() from firing when they are supposed to. PlayerSave provides a number of useful ways to modify tables in a player's save. For example, to insert a value into a list, you can simply call: save:ListInsert(&quot;Inventory&quot;, &quot;Sword)  If your use case is not covered by methods like save:ListInsert(), save:ListRemove(), or save:ListSwapRemove(), you can use the method save:GetDeepCopy() to get a copy of a saved value which is safe to mutate: local inventory = save:GetDeepCopy(&quot;Inventory&quot;, {}) table.insert(inventory, &quot;Sword&quot;) -- OK, since this is a deep copy of save data! save:Set(&quot;Inventory&quot;, inventory) -- OK!  "},{"title":"Setting Mutable Tables in a Save​","type":1,"pageTitle":"Incorrect API Usage","url":"/docs/incorrect_api_usage#setting-mutable-tables-in-a-save","content":"info PlayerSave will automatically make deep copies of tables passed into save:Set(), or as a second argument (defaultValue) to save:Get(). This means you do not have to worry about mutating values that are later stored in a save. local myTable = {} save:Set(&quot;Value1&quot;, myTable) -- OK table.insert(myTable, &quot;Foo&quot;) -- OK; this will not affect Value1! save:Get(&quot;Value2&quot;, myTable) -- OK table.insert(myTable, &quot;Fighters&quot;) -- OK; this will not affect Value1 or Value2! print(#save:Get(&quot;Value1&quot;)) -- 0 print(#save:Get(&quot;Value2&quot;)) -- 1 print(#myTable) -- 2  "},{"title":"Unsecured Remotes​","type":1,"pageTitle":"Incorrect API Usage","url":"/docs/incorrect_api_usage#unsecured-remotes","content":"One limitation of all player saving systems, which PlayerSave is by no means immune to, is the possibility of exploited data ending up in a player's save. Whenever you write code that listens to a RemoteEvent / RemoteFunction, you should never trust values sent from the client to the server! Failing to perform sanity checks on values sent by the client could result in exploits that remain in a player's save forever. caution Never trust values sent from the client to the server! Unsecured Remote Example (using Knit): function LevelUpService.Client:SpendExperienceShards( player: Player, amount: number ) local save = PlayerSave.Get(player) save:Increment(&quot;ExperienceShards&quot;, -amount) save:Increment(&quot;ExperienceLevel&quot;, amount) end Exploiters are able to call any remote function with arbitrary arguments. Take a moment to consider what the net effect would be after making any of the following requests: LevelUpService:SpendExperienceShards(-100000) LevelUpService:SpendExperienceShards(math.huge) LevelUpService:SpendExperienceShards(1/0) LevelUpService:SpendExperienceShards(0/0) LevelUpService:SpendExperienceShards(0.000001) LevelUpService:SpendExperienceShards(0) LevelUpService:SpendExperienceShards(Vector3.new(0.5, -1, 1 / 0)) LevelUpService:SpendExperienceShards(&quot;Oops, I corrupted the save!&quot;)  info It's a good idea to perform sanity checks on values provided by the client that will end up in a player's save. Example of a secured remote: function LevelUpService.Client:SpendExperienceShards( player: Player, amount: unknown -- Never assume the type of a value sent by a player! ) -- Loaded save check local save = PlayerSave.GetLoaded(player) if not save then return end -- Type check if typeof(amount) ~= &quot;number&quot; then return end -- NaN check if amount ~= amount then return end -- Range check local currentShards = save:Get(&quot;ExperienceShards&quot;, 0) if amount &lt; 1 or amount &gt; currentShards then return end -- Integer check if amount ~= math.floor(amount) then return end -- All sanity checks have passed! Now we are safe to edit the player's data. save:Increment(&quot;ExperienceShards&quot;, -amount) save:Increment(&quot;ExperienceLevel&quot;, amount) end  "}]