"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[171],{3824:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"incorrect_api_usage","title":"Incorrect API Usage","description":"PlayerSave\'s API has a few key limitations to look out for!","source":"@site/docs/incorrect_api_usage.md","sourceDirName":".","slug":"/incorrect_api_usage","permalink":"/docs/incorrect_api_usage","draft":false,"unlisted":false,"editUrl":"https://github.com/AmberGraceSoftware/PlayerSave/edit/master/docs/incorrect_api_usage.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Mechanisms","permalink":"/docs/mechanisms"}}');var r=a(4848),s=a(8453);const i={sidebar_position:3},o="Incorrect API Usage",l={},c=[{value:"Table Mutations",id:"table-mutations",level:2},{value:"Setting Mutable Tables in a Save",id:"setting-mutable-tables-in-a-save",level:2},{value:"Unsecured Remotes",id:"unsecured-remotes",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"incorrect-api-usage",children:"Incorrect API Usage"})}),"\n",(0,r.jsx)(n.p,{children:"PlayerSave's API has a few key limitations to look out for!"}),"\n",(0,r.jsx)(n.h2,{id:"table-mutations",children:"Table Mutations"}),"\n",(0,r.jsxs)(n.p,{children:["One core feature of PlayerSave is that all changes to player save data are ",(0,r.jsx)(n.a,{href:"../api/Save#Subscribe",children:"Observable"}),". This is achieved by only allowing data to be changed in a player's save via ",(0,r.jsx)(n.a,{href:"../api/Save#Set",children:"Setter methods"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"However"}),", ",(0,r.jsx)(n.strong,{children:"there are still ways to accidentally modify save data"})," that the PlayerSave library is not able to observe to at runtime!"]}),"\n",(0,r.jsxs)(n.admonition,{type:"warning",children:[(0,r.jsxs)(n.p,{children:["You should never directly edit a table returned by ",(0,r.jsx)(n.a,{href:"../api/Save#Get",children:(0,r.jsx)(n.code,{children:"save:Get()"})}),"! For example:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local inventory = save:Get("Inventory", {})\ntable.insert(inventory, "Sword") -- Incorrect! `inventory` should not be mutated\nsave:Set("Inventory", inventory) -- Will throw an error.\n'})}),(0,r.jsxs)(n.p,{children:["Mutating a value directly like this will result in ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"desynchronization"})})," between server data and client data. It may also prevent listeners connected via ",(0,r.jsx)(n.a,{href:"../api/Save#Subscribe",children:(0,r.jsx)(n.code,{children:"save:Subscribe()"})})," from firing when they are supposed to."]})]}),"\n",(0,r.jsx)(n.p,{children:"PlayerSave provides a number of useful ways to modify tables in a player's save.\nFor example, to insert a value into a list, you can simply call:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'save:ListInsert("Inventory", "Sword)\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If your use case is not covered by methods like ",(0,r.jsx)(n.a,{href:"../api/Save#ListInsert",children:(0,r.jsx)(n.code,{children:"save:ListInsert()"})}),", ",(0,r.jsx)(n.a,{href:"../api/Save#ListRemove",children:(0,r.jsx)(n.code,{children:"save:ListRemove()"})}),", or ",(0,r.jsx)(n.a,{href:"../api/Save#ListSwapRemove",children:(0,r.jsx)(n.code,{children:"save:ListSwapRemove()"})}),", you can use the method ",(0,r.jsx)(n.a,{href:"../api/Save#GetDeepCopy",children:(0,r.jsx)(n.code,{children:"save:GetDeepCopy()"})})," to get a copy of a saved value which is safe to mutate:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local inventory = save:GetDeepCopy("Inventory", {})\ntable.insert(inventory, "Sword") -- OK, since this is a deep copy of save data!\nsave:Set("Inventory", inventory) -- OK!\n'})}),"\n",(0,r.jsx)(n.h2,{id:"setting-mutable-tables-in-a-save",children:"Setting Mutable Tables in a Save"}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:["PlayerSave will automatically make deep copies of tables passed into ",(0,r.jsx)(n.a,{href:"../api/Save#Set",children:(0,r.jsx)(n.code,{children:"save:Set()"})}),", or as a second argument (",(0,r.jsx)(n.code,{children:"defaultValue"}),") to ",(0,r.jsx)(n.a,{href:"../api/Save#Get",children:(0,r.jsx)(n.code,{children:"save:Get()"})}),"."]}),(0,r.jsx)(n.p,{children:"This means you do not have to worry about mutating values that are later stored in a save."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local myTable = {}\nsave:Set("Value1", myTable) -- OK\ntable.insert(myTable, "Foo") -- OK; this will not affect Value1!\nsave:Get("Value2", myTable) -- OK\ntable.insert(myTable, "Fighters") -- OK; this will not affect Value1 or Value2!\n\nprint(#save:Get("Value1")) -- 0\nprint(#save:Get("Value2")) -- 1\nprint(#myTable) -- 2\n'})})]}),"\n",(0,r.jsx)(n.h2,{id:"unsecured-remotes",children:"Unsecured Remotes"}),"\n",(0,r.jsx)(n.p,{children:"One limitation of all player saving systems, which PlayerSave is by no means immune to, is the possibility of exploited data ending up in a player's save."}),"\n",(0,r.jsxs)(n.p,{children:["Whenever you write code that listens to a RemoteEvent / RemoteFunction, you should ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"never trust values sent from the client to the server!"})})," Failing to perform sanity checks on values sent by the client could result in exploits that remain in a player's save forever."]}),"\n",(0,r.jsxs)(n.admonition,{type:"caution",children:[(0,r.jsx)(n.p,{children:"Never trust values sent from the client to the server!"}),(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Unsecured Remote Example (using ",(0,r.jsx)(n.a,{href:"https://sleitnick.github.io/Knit/",children:"Knit"}),"):"]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function LevelUpService.Client:SpendExperienceShards(\n    player: Player,\n    amount: number\n)\n    local save = PlayerSave.Get(player)\n    save:Increment("ExperienceShards", -amount)\n    save:Increment("ExperienceLevel", amount)\nend\n'})}),(0,r.jsx)(n.p,{children:"Exploiters are able to call any remote function with arbitrary arguments. Take a moment to consider what the net effect would be after making any of the following requests:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'LevelUpService:SpendExperienceShards(-100000)\nLevelUpService:SpendExperienceShards(math.huge)\nLevelUpService:SpendExperienceShards(1/0)\nLevelUpService:SpendExperienceShards(0/0)\nLevelUpService:SpendExperienceShards(0.000001)\nLevelUpService:SpendExperienceShards(0)\nLevelUpService:SpendExperienceShards(Vector3.new(0.5, -1, 1 / 0))\nLevelUpService:SpendExperienceShards("Oops, I corrupted the save!")\n'})})]}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsx)(n.p,{children:"It's a good idea to perform sanity checks on values provided by the client that will end up in a player's save."}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example of a secured remote:"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'function LevelUpService.Client:SpendExperienceShards(\n    player: Player,\n    amount: unknown -- Never assume the type of a value sent by a player!\n)\n    -- Loaded save check\n    local save = PlayerSave.GetLoaded(player)\n    if not save then\n        return\n    end\n    -- Type check\n    if typeof(amount) ~= "number" then\n        return\n    end\n    -- NaN check\n    if amount ~= amount then\n        return\n    end\n    -- Range check\n    local currentShards = save:Get("ExperienceShards", 0)\n    if amount < 1 or amount > currentShards then\n        return\n    end\n    -- Integer check\n    if amount ~= math.floor(amount) then\n        return\n    end\n\n    -- All sanity checks have passed! Now we are safe to edit the player\'s data.\n\n    save:Increment("ExperienceShards", -amount)\n    save:Increment("ExperienceLevel", amount)\nend\n'})})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>o});var t=a(6540);const r={},s=t.createContext(r);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);